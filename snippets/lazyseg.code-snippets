{

	"Abeshek C++ Template": {
		"prefix": "lazysegtemp",
		"body": [
			"struct segTree",
"{",
    "\tll size;",
    "\tvll data, delta; // delta contains operations",
    "\tll neutral;",
"",
    "\tsegTree(ll n)",
    "\t{",
        "\t\tsize = 1;",
        "\t\twhile (size < n)",
            "\t\t\tsize *= 2ll;",
        "\t\tdata.assign(2 * size, 0ll); // fill depending on what data stores",
        "\t\tdelta.assign(2 * size, 0ll);",
        "\t\tneutral = 0;",
    "\t}",
"",
    "\tvoid build(const vll &a,ll node,ll l,ll r)",
    "\t{",
        "\t\tif(l == r)",
        "\t\t{",
            "\t\t\tdata[node] = a[node-(size>>1)-1];",
            "\t\t\treturn;",
        "\t\t}",
        "\t\tll mid = l+(r-l)/2;",
        "\t\tll left = 2*node+1;",
        "\t\tll right = 2*node+2;",
        "\t\tbuild(a,left,l,mid);",
        "\t\tbuild(a,right,mid+1,r);",
    "\t}",
    "\tvoid build(const vll &a)",
    "\t{",
        "\t\tbuild(a,0,0,a.size()-1);",
    "\t}",
"",
    "\tll op(ll a, ll b) // used in update , query , prop",
    "\t{",
        "\t\treturn a + b;",
    "\t}",
"",
    "\tll op2(ll a,ll b)",
    "\t{",
        "\t\treturn min(a,b);",
    "\t}",
"",
    "\tvoid update(ll node) // update parent",
    "\t{",
        "\t\tll left = 2 * node + 1;",
        "\t\tll right = 2 * node + 2;",
        "\t\tdata[node] = op2(data[left]+delta[left], data[right]+delta[right]);",
    "\t}",
"",
    "\tvoid prop(ll node)",
    "\t{",
        "\t\tll left = 2 * node + 1;",
        "\t\tll right = 2 * node + 2;",
        "\t\t// operation here depends on what we modify",
        "\t\tdelta[left] += delta[node];",
        "\t\tdelta[right] += delta[node];",
        "\t\tdelta[node] = 0;",
    "\t}",
"",
    "\tvoid modify(ll l, ll r, ll val, ll node, ll lo, ll hi)",
    "\t{",
        "\t\tif (l > hi || r < lo)",
        "\t\t{",
            "\t\t\treturn;",
        "\t\t}",
        "\t\tif (l <= lo && r >= hi)",
        "\t\t{",
            "\t\t\tdelta[node] += val;",
            "\t\t\treturn;",
        "\t\t}",
        "\t\tll mid = lo + (hi - lo) / 2;",
        "\t\tif (lo != hi)",
        "\t\t{",
            "\t\t\tprop(node);",
        "\t\t}",
        "\t\tmodify(l, r, val, 2 * node + 1, lo, mid);",
        "\t\tmodify(l, r, val, 2 * node + 2, mid + 1, hi);",
        "\t\tupdate(node);",
    "\t}",
"",
    "\tvoid modify(ll l, ll r, ll val) // set data[indx] = val",
    "\t{",
        "\t\tmodify(l, r, val, 0, 0, size - 1);",
    "\t}",
"",
    "\tll query(ll l, ll r, ll node, ll lo, ll hi)",
    "\t{",
        "\t\tif (l > hi || r < lo)",
        "\t\t{",
            "\t\t\treturn INF;",
        "\t\t}",
        "\t\tif (l <= lo && r >= hi)",
        "\t\t{",
            "\t\t\treturn data[node] + delta[node];",
        "\t\t}",
        "\t\tif (lo != hi)",
        "\t\t{",
            "\t\t\tprop(node);",
        "\t\t}",
        "\t\tll mid = lo + (hi - lo) / 2;",
        "\t\tll left_val = query(l, r, 2 * node + 1, lo, mid);",
        "\t\tll right_val = query(l, r, 2 * node + 2, mid + 1, hi);",
        "\t\tupdate(node);",
        "\t\treturn op2(left_val, right_val);",
    "\t}",
"",
    "\tll query(ll l, ll r)",
    "\t{",
        "\t\treturn query(l, r, 0, 0, size - 1);",
    "\t}",
"};"
		],
		"description": "My custom segment tree template for lazy propagation"
	}
}