{
	"Abeshek C++ Template": {
		"prefix": "modnum",
		"body": [
			"template <int MOD_>",
"struct modnum",
"{",
  "\tstatic constexpr int MOD = MOD_;",
  "\tstatic_assert(MOD_ > 0, \"MOD must be positive\");",
"",
"private:",
  "\tusing ll = long long;",
"",
  "\tint v;",
"",
  "\tstatic int minv(int a, int m)",
  "\t{",
    "\t\ta %= m;",
    "\t\tassert(a);",
    "\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);",
  "\t}",
"",
"public:",
  "\tmodnum() : v(0) {}",
  "\tmodnum(ll v_) : v(int(v_ % MOD))",
  "\t{",
    "\t\tif (v < 0)",
      "\t\t\tv += MOD;",
  "\t}",
  "\texplicit operator int() const { return v; }",
  "\tfriend std::ostream &operator<<(std::ostream &out, const modnum &n) { return out << int(n); }",
  "\tfriend std::istream &operator>>(std::istream &in, modnum &n)",
  "\t{",
    "\t\tll v_;",
    "\t\tin >> v_;",
    "\t\tn = modnum(v_);",
    "\t\treturn in;",
  "\t}",
"",
  "\tfriend bool operator==(const modnum &a, const modnum &b) { return a.v == b.v; }",
  "\tfriend bool operator!=(const modnum &a, const modnum &b) { return a.v != b.v; }",
"",
  "\tmodnum inv() const",
  "\t{",
    "\t\tmodnum res;",
    "\t\tres.v = minv(v, MOD);",
    "\t\treturn res;",
  "\t}",
  "\tfriend modnum inv(const modnum &m) { return m.inv(); }",
  "\tmodnum neg() const",
  "\t{",
    "\t\tmodnum res;",
    "\t\tres.v = v ? MOD - v : 0;",
    "\t\treturn res;",
  "\t}",
  "\tfriend modnum neg(const modnum &m) { return m.neg(); }",
"",
  "\tmodnum operator-() const",
  "\t{",
    "\t\treturn neg();",
  "\t}",
  "\tmodnum operator+() const",
  "\t{",
    "\t\treturn modnum(*this);",
  "\t}",
"",
  "\tmodnum &operator++()",
  "\t{",
    "\t\tv++;",
    "\t\tif (v == MOD)",
      "\t\t\tv = 0;",
    "\t\treturn *this;",
  "\t}",
  "\tmodnum &operator--()",
  "\t{",
    "\t\tif (v == 0)",
      "\t\t\tv = MOD;",
    "\t\tv--;",
    "\t\treturn *this;",
  "\t}",
  "\tmodnum &operator+=(const modnum &o)",
  "\t{",
    "\t\tv += o.v;",
    "\t\tif (v >= MOD)",
      "\t\t\tv -= MOD;",
    "\t\treturn *this;",
  "\t}",
  "\tmodnum &operator-=(const modnum &o)",
  "\t{",
    "\t\tv -= o.v;",
    "\t\tif (v < 0)",
      "\t\t\tv += MOD;",
    "\t\treturn *this;",
  "\t}",
  "\tmodnum &operator*=(const modnum &o)",
  "\t{",
    "\t\tv = int(ll(v) * ll(o.v) % MOD);",
    "\t\treturn *this;",
  "\t}",
  "\tmodnum &operator/=(const modnum &o)",
  "\t{",
    "\t\treturn *this *= o.inv();",
  "\t}",
"",
  "\tfriend modnum operator++(modnum &a, int)",
  "\t{",
    "\t\tmodnum r = a;",
    "\t\t++a;",
    "\t\treturn r;",
  "\t}",
  "\tfriend modnum operator--(modnum &a, int)",
  "\t{",
    "\t\tmodnum r = a;",
    "\t\t--a;",
    "\t\treturn r;",
  "\t}",
  "\tfriend modnum operator+(const modnum &a, const modnum &b) { return modnum(a) += b; }",
  "\tfriend modnum operator-(const modnum &a, const modnum &b) { return modnum(a) -= b; }",
  "\tfriend modnum operator*(const modnum &a, const modnum &b) { return modnum(a) *= b; }",
  "\tfriend modnum operator/(const modnum &a, const modnum &b) { return modnum(a) /= b; }",
"};",
"",
"template <typename T>",
"T pow(T a, long long b)",
"{",
  "\tassert(b >= 0);",
  "\tT r = 1;",
  "\twhile (b)",
  "\t{",
    "\t\tif (b & 1)",
      "\t\t\tr *= a;",
    "\t\tb >>= 1;",
    "\t\ta *= a;",
  "\t}",
  "\treturn r;",
"}",
"",
"// change mod for convenience",
"using Mint = modnum<mod>;"
		],
		"description": "My custom c++ template"
	}
}